/// <reference types="node" />
import { BookshelfRepository, OrderOption } from '@tryghost/bookshelf-repository';
import { AddRecommendation, Recommendation, RecommendationPlain } from './Recommendation';
import { RecommendationRepository } from './RecommendationRepository';
import { WellknownService } from './WellknownService';
import { ClickEvent } from './ClickEvent';
import { SubscribeEvent } from './SubscribeEvent';
export type RecommendationIncludeTypes = {
    'count.clicks': number;
    'count.subscribers': number;
};
export type RecommendationIncludeFields = keyof RecommendationIncludeTypes;
/**
 * All includes are optional, but if they are explicitly loaded, they will not be optional in the result.
 *
 * E.g. RecommendationWithIncludes['count.clicks'|'count.subscribers'].
 *
 * When using methods like listRecommendations with the include option, the result will automatically return the correct relations
 */
export type RecommendationWithIncludes<IncludeFields extends RecommendationIncludeFields = never> = RecommendationPlain & Partial<RecommendationIncludeTypes> & Record<IncludeFields, RecommendationIncludeTypes[IncludeFields]>;
type MentionSendingService = {
    sendAll(options: {
        url: URL;
        links: URL[];
    }): Promise<void>;
};
type RecommendationEnablerService = {
    getSetting(): string;
    setSetting(value: string): Promise<void>;
};
export declare class RecommendationService {
    #private;
    repository: RecommendationRepository;
    clickEventRepository: BookshelfRepository<string, ClickEvent>;
    subscribeEventRepository: BookshelfRepository<string, SubscribeEvent>;
    wellknownService: WellknownService;
    mentionSendingService: MentionSendingService;
    recommendationEnablerService: RecommendationEnablerService;
    constructor(deps: {
        repository: RecommendationRepository;
        clickEventRepository: BookshelfRepository<string, ClickEvent>;
        subscribeEventRepository: BookshelfRepository<string, SubscribeEvent>;
        wellknownService: WellknownService;
        mentionSendingService: MentionSendingService;
        recommendationEnablerService: RecommendationEnablerService;
    });
    init(): Promise<void>;
    updateWellknown(recommendations: Recommendation[]): Promise<void>;
    updateRecommendationsEnabledSetting(recommendations: Recommendation[]): Promise<void>;
    private sendMentionToRecommendation;
    readRecommendation(id: string): Promise<RecommendationPlain>;
    addRecommendation(addRecommendation: AddRecommendation): Promise<RecommendationPlain>;
    editRecommendation(id: string, recommendationEdit: Partial<Recommendation>): Promise<RecommendationPlain>;
    deleteRecommendation(id: string): Promise<void>;
    /**
     * Same as #listRecommendations, but with includes and returns a plain object for external use
     */
    listRecommendations<IncludeFields extends RecommendationIncludeFields = never>({ page, limit, filter, order, include }?: {
        page: number;
        limit: number | 'all';
        filter?: string;
        order?: OrderOption<Recommendation>;
        include?: IncludeFields[];
    }): Promise<RecommendationWithIncludes<IncludeFields>[]>;
    loadRelations<IncludeFields extends RecommendationIncludeFields>(list: Recommendation[], include?: IncludeFields[]): Promise<RecommendationWithIncludes<IncludeFields>[]>;
    countRecommendations({ filter }: {
        filter?: string;
    }): Promise<number>;
    trackClicked({ id, memberId }: {
        id: string;
        memberId?: string;
    }): Promise<void>;
    trackSubscribed({ id, memberId }: {
        id: string;
        memberId: string;
    }): Promise<void>;
}
export {};
