"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecommendationService = void 0;
const Recommendation_1 = require("./Recommendation");
const errors_1 = __importDefault(require("@tryghost/errors"));
const tpl_1 = __importDefault(require("@tryghost/tpl"));
const ClickEvent_1 = require("./ClickEvent");
const SubscribeEvent_1 = require("./SubscribeEvent");
const logging_1 = __importDefault(require("@tryghost/logging"));
const messages = {
    notFound: 'Recommendation with id {id} not found'
};
class RecommendationService {
    repository;
    clickEventRepository;
    subscribeEventRepository;
    wellknownService;
    mentionSendingService;
    recommendationEnablerService;
    constructor(deps) {
        this.repository = deps.repository;
        this.wellknownService = deps.wellknownService;
        this.mentionSendingService = deps.mentionSendingService;
        this.recommendationEnablerService = deps.recommendationEnablerService;
        this.clickEventRepository = deps.clickEventRepository;
        this.subscribeEventRepository = deps.subscribeEventRepository;
    }
    async init() {
        const recommendations = await this.#listRecommendations();
        await this.updateWellknown(recommendations);
    }
    async updateWellknown(recommendations) {
        await this.wellknownService.set(recommendations);
    }
    async updateRecommendationsEnabledSetting(recommendations) {
        const expectedSetting = (recommendations.length > 0).toString();
        const currentSetting = this.recommendationEnablerService.getSetting();
        if (currentSetting && currentSetting === expectedSetting) {
            return;
        }
        await this.recommendationEnablerService.setSetting(expectedSetting);
    }
    sendMentionToRecommendation(recommendation) {
        this.mentionSendingService.sendAll({
            url: this.wellknownService.getURL(),
            links: [
                recommendation.url
            ]
        }).catch((err) => {
            logging_1.default.error('Failed to send mention to recommendation', err);
        });
    }
    async readRecommendation(id) {
        const recommendation = await this.repository.getById(id);
        if (!recommendation) {
            throw new errors_1.default.NotFoundError({
                message: (0, tpl_1.default)(messages.notFound, { id })
            });
        }
        return recommendation.plain;
    }
    async addRecommendation(addRecommendation) {
        const recommendation = Recommendation_1.Recommendation.create(addRecommendation);
        // If a recommendation with this URL already exists, throw an error
        const existing = await this.repository.getByUrl(recommendation.url);
        if (existing && existing.length > 0) {
            throw new errors_1.default.ValidationError({
                message: 'A recommendation with this URL already exists.'
            });
        }
        await this.repository.save(recommendation);
        const recommendations = await this.#listRecommendations();
        await this.updateWellknown(recommendations);
        await this.updateRecommendationsEnabledSetting(recommendations);
        // Only send an update for the mentioned URL
        this.sendMentionToRecommendation(recommendation);
        return recommendation.plain;
    }
    async editRecommendation(id, recommendationEdit) {
        // Check if it exists
        const existing = await this.repository.getById(id);
        if (!existing) {
            throw new errors_1.default.NotFoundError({
                message: (0, tpl_1.default)(messages.notFound, { id })
            });
        }
        existing.edit(recommendationEdit);
        await this.repository.save(existing);
        const recommendations = await this.#listRecommendations();
        await this.updateWellknown(recommendations);
        this.sendMentionToRecommendation(existing);
        return existing.plain;
    }
    async deleteRecommendation(id) {
        const existing = await this.repository.getById(id);
        if (!existing) {
            throw new errors_1.default.NotFoundError({
                message: (0, tpl_1.default)(messages.notFound, { id })
            });
        }
        existing.delete();
        await this.repository.save(existing);
        const recommendations = await this.#listRecommendations();
        await this.updateWellknown(recommendations);
        await this.updateRecommendationsEnabledSetting(recommendations);
        // Send a mention (because it was deleted, according to the webmentions spec)
        this.sendMentionToRecommendation(existing);
    }
    async #listRecommendations({ page, limit, filter, order } = { page: 1, limit: 'all' }) {
        let list;
        if (limit === 'all') {
            list = await this.repository.getAll({ filter, order });
        }
        else {
            if (page < 1) {
                throw new errors_1.default.BadRequestError({ message: 'page must be greater or equal to 1' });
            }
            if (limit < 1) {
                throw new errors_1.default.BadRequestError({ message: 'limit must be greater or equal to 1' });
            }
            list = await this.repository.getPage({ page, limit, filter, order });
        }
        return list;
    }
    /**
     * Same as #listRecommendations, but with includes and returns a plain object for external use
     */
    async listRecommendations({ page, limit, filter, order, include } = { page: 1, limit: 'all', include: [] }) {
        const list = await this.#listRecommendations({ page, limit, filter, order });
        return await this.loadRelations(list, include);
    }
    async loadRelations(list, include) {
        const plainList = list.map(e => e.plain);
        if (!include || !include.length) {
            return plainList;
        }
        if (list.length === 0) {
            // Avoid doing queries with broken filters
            return plainList;
        }
        for (const relation of include) {
            switch (relation) {
                case 'count.clicks':
                    const clickCounts = await this.clickEventRepository.getGroupedCount({ groupBy: 'recommendationId', filter: `recommendationId:[${list.map(entity => entity.id).join(',')}]` });
                    // Set all to zero by default
                    for (const entity of plainList) {
                        entity[relation] = 0;
                    }
                    for (const r of clickCounts) {
                        const entity = plainList.find(e => e.id === r.recommendationId);
                        if (entity) {
                            entity[relation] = r.count;
                        }
                    }
                    break;
                case 'count.subscribers':
                    const subscribersCounts = await this.subscribeEventRepository.getGroupedCount({ groupBy: 'recommendationId', filter: `recommendationId:[${list.map(entity => entity.id).join(',')}]` });
                    // Set all to zero by default
                    for (const entity of plainList) {
                        entity[relation] = 0;
                    }
                    for (const r of subscribersCounts) {
                        const entity = plainList.find(e => e.id === r.recommendationId);
                        if (entity) {
                            entity[relation] = r.count;
                        }
                    }
                    break;
                default:
                    // Should create a Type compile error in case we didn't catch all relations
                    const r = relation;
                    console.error(`Unknown relation ${r}`); // eslint-disable-line no-console
            }
        }
        return plainList;
    }
    async countRecommendations({ filter }) {
        return await this.repository.getCount({ filter });
    }
    async trackClicked({ id, memberId }) {
        const clickEvent = ClickEvent_1.ClickEvent.create({ recommendationId: id, memberId });
        await this.clickEventRepository.save(clickEvent);
    }
    async trackSubscribed({ id, memberId }) {
        const subscribeEvent = SubscribeEvent_1.SubscribeEvent.create({ recommendationId: id, memberId });
        await this.subscribeEventRepository.save(subscribeEvent);
    }
}
exports.RecommendationService = RecommendationService;
//# sourceMappingURL=RecommendationService.js.map