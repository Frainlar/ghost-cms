"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecommendationController = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const errors_1 = __importDefault(require("@tryghost/errors"));
const UnsafeData_1 = require("./UnsafeData");
class RecommendationController {
    service;
    constructor(deps) {
        this.service = deps.service;
    }
    async read(frame) {
        const options = new UnsafeData_1.UnsafeData(frame.options);
        const id = options.key('id').string;
        const recommendation = await this.service.readRecommendation(id);
        return this.#serialize([recommendation]);
    }
    async add(frame) {
        const data = new UnsafeData_1.UnsafeData(frame.data);
        const recommendation = data.key('recommendations').index(0);
        const plain = {
            title: recommendation.key('title').string,
            url: recommendation.key('url').url,
            // Optional fields
            oneClickSubscribe: recommendation.optionalKey('one_click_subscribe')?.boolean ?? false,
            reason: recommendation.optionalKey('reason')?.nullable.string ?? null,
            excerpt: recommendation.optionalKey('excerpt')?.nullable.string ?? null,
            featuredImage: recommendation.optionalKey('featured_image')?.nullable.url ?? null,
            favicon: recommendation.optionalKey('favicon')?.nullable.url ?? null
        };
        return this.#serialize([await this.service.addRecommendation(plain)]);
    }
    async edit(frame) {
        const options = new UnsafeData_1.UnsafeData(frame.options);
        const data = new UnsafeData_1.UnsafeData(frame.data);
        const recommendation = data.key('recommendations').index(0);
        const id = options.key('id').string;
        const plain = {
            title: recommendation.optionalKey('title')?.string,
            url: recommendation.optionalKey('url')?.url,
            oneClickSubscribe: recommendation.optionalKey('one_click_subscribe')?.boolean,
            reason: recommendation.optionalKey('reason')?.nullable.string,
            excerpt: recommendation.optionalKey('excerpt')?.nullable.string,
            featuredImage: recommendation.optionalKey('featured_image')?.nullable.url,
            favicon: recommendation.optionalKey('favicon')?.nullable.url
        };
        return this.#serialize([await this.service.editRecommendation(id, plain)]);
    }
    async destroy(frame) {
        const options = new UnsafeData_1.UnsafeData(frame.options);
        const id = options.key('id').string;
        await this.service.deleteRecommendation(id);
    }
    async browse(frame) {
        const options = new UnsafeData_1.UnsafeData(frame.options);
        const page = options.optionalKey('page')?.integer ?? 1;
        const limit = options.optionalKey('limit')?.integer ?? 5;
        const include = options.optionalKey('withRelated')?.array.map(item => item.enum(['count.clicks', 'count.subscribers'])) ?? [];
        const filter = options.optionalKey('filter')?.string;
        const orderOption = options.optionalKey('order')?.regex(/^[a-zA-Z]+ (asc|desc)$/) ?? 'createdAt desc';
        const field = orderOption?.split(' ')[0];
        const direction = orderOption?.split(' ')[1];
        const order = [
            {
                field,
                direction
            }
        ];
        const count = await this.service.countRecommendations({});
        const recommendations = (await this.service.listRecommendations({ page, limit, filter, include, order }));
        return this.#serialize(recommendations, {
            pagination: this.#serializePagination({ page, limit, count })
        });
    }
    async trackClicked(frame) {
        const member = this.#optionalAuthMember(frame);
        const options = new UnsafeData_1.UnsafeData(frame.options);
        const id = options.key('id').string;
        await this.service.trackClicked({
            id,
            memberId: member?.id
        });
    }
    async trackSubscribed(frame) {
        const member = this.#authMember(frame);
        const options = new UnsafeData_1.UnsafeData(frame.options);
        const id = options.key('id').string;
        await this.service.trackSubscribed({
            id,
            memberId: member.id
        });
    }
    #authMember(frame) {
        const options = new UnsafeData_1.UnsafeData(frame.options);
        const memberId = options.key('context').optionalKey('member')?.nullable.key('id').string;
        if (!memberId) {
            // This is an internal server error because authentication should happen outside this service.
            throw new errors_1.default.UnauthorizedError({
                message: 'Member not found'
            });
        }
        return {
            id: memberId
        };
    }
    #optionalAuthMember(frame) {
        try {
            const member = this.#authMember(frame);
            return member;
        }
        catch (e) {
            if (e instanceof errors_1.default.UnauthorizedError) {
                // This is fine, this is not required
            }
            else {
                throw e;
            }
        }
        return null;
    }
    #serialize(recommendations, meta) {
        return {
            data: recommendations.map((entity) => {
                const d = {
                    id: entity.id,
                    title: entity.title,
                    reason: entity.reason,
                    excerpt: entity.excerpt,
                    featured_image: entity.featuredImage?.toString() ?? null,
                    favicon: entity.favicon?.toString() ?? null,
                    url: entity.url.toString(),
                    one_click_subscribe: entity.oneClickSubscribe,
                    created_at: entity.createdAt,
                    updated_at: entity.updatedAt,
                    count: undefined
                };
                for (const [key, value] of Object.entries(entity)) {
                    if (key === 'count.clicks') {
                        if (typeof value !== 'number') {
                            continue;
                        }
                        d.count = {
                            ...(d.count ?? {}),
                            clicks: value
                        };
                        continue;
                    }
                    if (key === 'count.subscribers') {
                        if (typeof value !== 'number') {
                            continue;
                        }
                        d.count = {
                            ...(d.count ?? {}),
                            subscribers: value
                        };
                        continue;
                    }
                }
                return d;
            }),
            meta
        };
    }
    #serializePagination({ page, limit, count }) {
        const pages = Math.ceil(count / limit);
        return {
            page,
            limit,
            total: count,
            pages,
            prev: page > 1 ? page - 1 : null,
            next: page < pages ? page + 1 : null
        };
    }
}
exports.RecommendationController = RecommendationController;
//# sourceMappingURL=RecommendationController.js.map